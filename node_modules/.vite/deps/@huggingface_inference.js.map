{
  "version": 3,
  "sources": ["../../@huggingface/inference/dist/index.mjs"],
  "sourcesContent": ["// src/utils/toArray.ts\nfunction toArray(obj) {\n  if (Array.isArray(obj)) {\n    return obj;\n  }\n  return [obj];\n}\n\n// src/vendor/fetch-event-source/parse.ts\nfunction getLines(onLine) {\n  let buffer;\n  let position;\n  let fieldLength;\n  let discardTrailingNewline = false;\n  return function onChunk(arr) {\n    if (buffer === void 0) {\n      buffer = arr;\n      position = 0;\n      fieldLength = -1;\n    } else {\n      buffer = concat(buffer, arr);\n    }\n    const bufLength = buffer.length;\n    let lineStart = 0;\n    while (position < bufLength) {\n      if (discardTrailingNewline) {\n        if (buffer[position] === 10 /* NewLine */) {\n          lineStart = ++position;\n        }\n        discardTrailingNewline = false;\n      }\n      let lineEnd = -1;\n      for (; position < bufLength && lineEnd === -1; ++position) {\n        switch (buffer[position]) {\n          case 58 /* Colon */:\n            if (fieldLength === -1) {\n              fieldLength = position - lineStart;\n            }\n            break;\n          case 13 /* CarriageReturn */:\n            discardTrailingNewline = true;\n          case 10 /* NewLine */:\n            lineEnd = position;\n            break;\n        }\n      }\n      if (lineEnd === -1) {\n        break;\n      }\n      onLine(buffer.subarray(lineStart, lineEnd), fieldLength);\n      lineStart = position;\n      fieldLength = -1;\n    }\n    if (lineStart === bufLength) {\n      buffer = void 0;\n    } else if (lineStart !== 0) {\n      buffer = buffer.subarray(lineStart);\n      position -= lineStart;\n    }\n  };\n}\nfunction getMessages(onId, onRetry, onMessage) {\n  let message = newMessage();\n  const decoder = new TextDecoder();\n  return function onLine(line, fieldLength) {\n    if (line.length === 0) {\n      onMessage?.(message);\n      message = newMessage();\n    } else if (fieldLength > 0) {\n      const field = decoder.decode(line.subarray(0, fieldLength));\n      const valueOffset = fieldLength + (line[fieldLength + 1] === 32 /* Space */ ? 2 : 1);\n      const value = decoder.decode(line.subarray(valueOffset));\n      switch (field) {\n        case \"data\":\n          message.data = message.data ? message.data + \"\\n\" + value : value;\n          break;\n        case \"event\":\n          message.event = value;\n          break;\n        case \"id\":\n          onId(message.id = value);\n          break;\n        case \"retry\":\n          const retry = parseInt(value, 10);\n          if (!isNaN(retry)) {\n            onRetry(message.retry = retry);\n          }\n          break;\n      }\n    }\n  };\n}\nfunction concat(a, b) {\n  const res = new Uint8Array(a.length + b.length);\n  res.set(a);\n  res.set(b, a.length);\n  return res;\n}\nfunction newMessage() {\n  return {\n    data: \"\",\n    event: \"\",\n    id: \"\",\n    retry: void 0\n  };\n}\n\n// src/HfInference.ts\nvar HF_INFERENCE_API_BASE_URL = \"https://api-inference.huggingface.co/models/\";\nvar TextGenerationStreamFinishReason = /* @__PURE__ */ ((TextGenerationStreamFinishReason2) => {\n  TextGenerationStreamFinishReason2[\"Length\"] = \"length\";\n  TextGenerationStreamFinishReason2[\"EndOfSequenceToken\"] = \"eos_token\";\n  TextGenerationStreamFinishReason2[\"StopSequence\"] = \"stop_sequence\";\n  return TextGenerationStreamFinishReason2;\n})(TextGenerationStreamFinishReason || {});\nvar HfInference = class {\n  apiKey;\n  defaultOptions;\n  constructor(apiKey = \"\", defaultOptions = {}) {\n    this.apiKey = apiKey;\n    this.defaultOptions = defaultOptions;\n  }\n  /**\n   * Tries to fill in a hole with a missing word (token to be precise). That’s the base task for BERT models.\n   */\n  async fillMask(args, options) {\n    const res = await this.request(args, options);\n    const isValidOutput = Array.isArray(res) && res.every(\n      (x) => typeof x.score === \"number\" && typeof x.sequence === \"string\" && typeof x.token === \"number\" && typeof x.token_str === \"string\"\n    );\n    if (!isValidOutput) {\n      throw new TypeError(\n        \"Invalid inference output: output must be of type Array<score: number, sequence:string, token:number, token_str:string>\"\n      );\n    }\n    return res;\n  }\n  /**\n   * This task is well known to summarize longer text into shorter text. Be careful, some models have a maximum length of input. That means that the summary cannot handle full books for instance. Be careful when choosing your model.\n   */\n  async summarization(args, options) {\n    const res = await this.request(args, options);\n    const isValidOutput = Array.isArray(res) && res.every((x) => typeof x.summary_text === \"string\");\n    if (!isValidOutput) {\n      throw new TypeError(\"Invalid inference output: output must be of type Array<summary_text: string>\");\n    }\n    return res?.[0];\n  }\n  /**\n   * Want to have a nice know-it-all bot that can answer any question?. Recommended model: deepset/roberta-base-squad2\n   */\n  async questionAnswer(args, options) {\n    const res = await this.request(args, options);\n    const isValidOutput = typeof res.answer === \"string\" && typeof res.end === \"number\" && typeof res.score === \"number\" && typeof res.start === \"number\";\n    if (!isValidOutput) {\n      throw new TypeError(\n        \"Invalid inference output: output must be of type <answer: string, end: number, score: number, start: number>\"\n      );\n    }\n    return res;\n  }\n  /**\n   * Don’t know SQL? Don’t want to dive into a large spreadsheet? Ask questions in plain english! Recommended model: google/tapas-base-finetuned-wtq.\n   */\n  async tableQuestionAnswer(args, options) {\n    const res = await this.request(args, options);\n    const isValidOutput = typeof res.aggregator === \"string\" && typeof res.answer === \"string\" && Array.isArray(res.cells) && res.cells.every((x) => typeof x === \"string\") && Array.isArray(res.coordinates) && res.coordinates.every((coord) => Array.isArray(coord) && coord.every((x) => typeof x === \"number\"));\n    if (!isValidOutput) {\n      throw new TypeError(\n        \"Invalid inference output: output must be of type <aggregator: string, answer: string, cells: string[], coordinates: number[][]>\"\n      );\n    }\n    return res;\n  }\n  /**\n   * Usually used for sentiment-analysis this will output the likelihood of classes of an input. Recommended model: distilbert-base-uncased-finetuned-sst-2-english\n   */\n  async textClassification(args, options) {\n    const res = (await this.request(args, options))?.[0];\n    const isValidOutput = Array.isArray(res) && res.every((x) => typeof x.label === \"string\" && typeof x.score === \"number\");\n    if (!isValidOutput) {\n      throw new TypeError(\"Invalid inference output: output must be of type Array<label: string, score: number>\");\n    }\n    return res;\n  }\n  /**\n   * Use to continue text from a prompt. This is a very generic task. Recommended model: gpt2 (it’s a simple model, but fun to play with).\n   */\n  async textGeneration(args, options) {\n    const res = await this.request(args, options);\n    const isValidOutput = Array.isArray(res) && res.every((x) => typeof x.generated_text === \"string\");\n    if (!isValidOutput) {\n      throw new TypeError(\"Invalid inference output: output must be of type Array<generated_text: string>\");\n    }\n    return res?.[0];\n  }\n  /**\n   * Use to continue text from a prompt. Same as `textGeneration` but returns generator that can be read one token at a time\n   */\n  async *textGenerationStream(args, options) {\n    yield* this.streamingRequest(args, options);\n  }\n  /**\n   * Usually used for sentence parsing, either grammatical, or Named Entity Recognition (NER) to understand keywords contained within text. Recommended model: dbmdz/bert-large-cased-finetuned-conll03-english\n   */\n  async tokenClassification(args, options) {\n    const res = toArray(await this.request(args, options));\n    const isValidOutput = Array.isArray(res) && res.every(\n      (x) => typeof x.end === \"number\" && typeof x.entity_group === \"string\" && typeof x.score === \"number\" && typeof x.start === \"number\" && typeof x.word === \"string\"\n    );\n    if (!isValidOutput) {\n      throw new TypeError(\n        \"Invalid inference output: output must be of type Array<end: number, entity_group: string, score: number, start: number, word: string>\"\n      );\n    }\n    return res;\n  }\n  /**\n   * This task is well known to translate text from one language to another. Recommended model: Helsinki-NLP/opus-mt-ru-en.\n   */\n  async translation(args, options) {\n    const res = await this.request(args, options);\n    const isValidOutput = Array.isArray(res) && res.every((x) => typeof x.translation_text === \"string\");\n    if (!isValidOutput) {\n      throw new TypeError(\"Invalid inference output: output must be of type Array<translation_text: string>\");\n    }\n    return res?.[0];\n  }\n  /**\n   * This task is super useful to try out classification with zero code, you simply pass a sentence/paragraph and the possible labels for that sentence, and you get a result. Recommended model: facebook/bart-large-mnli.\n   */\n  async zeroShotClassification(args, options) {\n    const res = toArray(\n      await this.request(args, options)\n    );\n    const isValidOutput = Array.isArray(res) && res.every(\n      (x) => Array.isArray(x.labels) && x.labels.every((_label) => typeof _label === \"string\") && Array.isArray(x.scores) && x.scores.every((_score) => typeof _score === \"number\") && typeof x.sequence === \"string\"\n    );\n    if (!isValidOutput) {\n      throw new TypeError(\n        \"Invalid inference output: output must be of type Array<labels: string[], scores: number[], sequence: string>\"\n      );\n    }\n    return res;\n  }\n  /**\n   * This task corresponds to any chatbot like structure. Models tend to have shorter max_length, so please check with caution when using a given model if you need long range dependency or not. Recommended model: microsoft/DialoGPT-large.\n   *\n   */\n  async conversational(args, options) {\n    const res = await this.request(args, options);\n    const isValidOutput = Array.isArray(res.conversation.generated_responses) && res.conversation.generated_responses.every((x) => typeof x === \"string\") && Array.isArray(res.conversation.past_user_inputs) && res.conversation.past_user_inputs.every((x) => typeof x === \"string\") && typeof res.generated_text === \"string\" && Array.isArray(res.warnings) && res.warnings.every((x) => typeof x === \"string\");\n    if (!isValidOutput) {\n      throw new TypeError(\n        \"Invalid inference output: output must be of type <conversation: {generated_responses: string[], past_user_inputs: string[]}, generated_text: string, warnings: string[]>\"\n      );\n    }\n    return res;\n  }\n  /**\n   * This task reads some text and outputs raw float values, that are usually consumed as part of a semantic database/semantic search.\n   */\n  async featureExtraction(args, options) {\n    const res = await this.request(args, options);\n    return res;\n  }\n  /**\n   * This task reads some audio input and outputs the said words within the audio files.\n   * Recommended model (english language): facebook/wav2vec2-large-960h-lv60-self\n   */\n  async automaticSpeechRecognition(args, options) {\n    const res = await this.request(args, {\n      ...options,\n      binary: true\n    });\n    const isValidOutput = typeof res.text === \"string\";\n    if (!isValidOutput) {\n      throw new TypeError(\"Invalid inference output: output must be of type <text: string>\");\n    }\n    return res;\n  }\n  /**\n   * This task reads some audio input and outputs the likelihood of classes.\n   * Recommended model:  superb/hubert-large-superb-er\n   */\n  async audioClassification(args, options) {\n    const res = await this.request(args, {\n      ...options,\n      binary: true\n    });\n    const isValidOutput = Array.isArray(res) && res.every((x) => typeof x.label === \"string\" && typeof x.score === \"number\");\n    if (!isValidOutput) {\n      throw new TypeError(\"Invalid inference output: output must be of type Array<label: string, score: number>\");\n    }\n    return res;\n  }\n  /**\n   * This task reads some image input and outputs the likelihood of classes.\n   * Recommended model: google/vit-base-patch16-224\n   */\n  async imageClassification(args, options) {\n    const res = await this.request(args, {\n      ...options,\n      binary: true\n    });\n    const isValidOutput = Array.isArray(res) && res.every((x) => typeof x.label === \"string\" && typeof x.score === \"number\");\n    if (!isValidOutput) {\n      throw new TypeError(\"Invalid inference output: output must be of type Array<label: string, score: number>\");\n    }\n    return res;\n  }\n  /**\n   * This task reads some image input and outputs the likelihood of classes & bounding boxes of detected objects.\n   * Recommended model: facebook/detr-resnet-50\n   */\n  async objectDetection(args, options) {\n    const res = await this.request(args, {\n      ...options,\n      binary: true\n    });\n    const isValidOutput = Array.isArray(res) && res.every(\n      (x) => typeof x.label === \"string\" && typeof x.score === \"number\" && typeof x.box.xmin === \"number\" && typeof x.box.ymin === \"number\" && typeof x.box.xmax === \"number\" && typeof x.box.ymax === \"number\"\n    );\n    if (!isValidOutput) {\n      throw new TypeError(\n        \"Invalid inference output: output must be of type Array<{label:string; score:number; box:{xmin:number; ymin:number; xmax:number; ymax:number}}>\"\n      );\n    }\n    return res;\n  }\n  /**\n   * This task reads some image input and outputs the likelihood of classes & bounding boxes of detected objects.\n   * Recommended model: facebook/detr-resnet-50-panoptic\n   */\n  async imageSegmentation(args, options) {\n    const res = await this.request(args, {\n      ...options,\n      binary: true\n    });\n    const isValidOutput = Array.isArray(res) && res.every((x) => typeof x.label === \"string\" && typeof x.mask === \"string\" && typeof x.score === \"number\");\n    if (!isValidOutput) {\n      throw new TypeError(\n        \"Invalid inference output: output must be of type Array<label: string, mask: string, score: number>\"\n      );\n    }\n    return res;\n  }\n  /**\n   * This task reads some text input and outputs an image.\n   * Recommended model: stabilityai/stable-diffusion-2\n   */\n  async textToImage(args, options) {\n    const res = await this.request(args, {\n      ...options,\n      blob: true\n    });\n    const isValidOutput = res && res instanceof Blob;\n    if (!isValidOutput) {\n      throw new TypeError(\"Invalid inference output: output must be of type object & of instance Blob\");\n    }\n    return res;\n  }\n  /**\n   * This task reads some image input and outputs the text caption.\n   */\n  async imageToText(args, options) {\n    return (await this.request(args, {\n      ...options,\n      binary: true\n    }))?.[0];\n  }\n  /**\n   * Helper that prepares request arguments\n   */\n  makeRequestOptions(args, options) {\n    const mergedOptions = { ...this.defaultOptions, ...options };\n    const { model, ...otherArgs } = args;\n    const headers = {};\n    if (this.apiKey) {\n      headers[\"Authorization\"] = `Bearer ${this.apiKey}`;\n    }\n    if (!options?.binary) {\n      headers[\"Content-Type\"] = \"application/json\";\n    }\n    if (options?.binary) {\n      if (mergedOptions.wait_for_model) {\n        headers[\"X-Wait-For-Model\"] = \"true\";\n      }\n      if (mergedOptions.use_cache === false) {\n        headers[\"X-Use-Cache\"] = \"false\";\n      }\n      if (mergedOptions.dont_load_model) {\n        headers[\"X-Load-Model\"] = \"0\";\n      }\n    }\n    const url = `${HF_INFERENCE_API_BASE_URL}${model}`;\n    const info = {\n      headers,\n      method: \"POST\",\n      body: options?.binary ? args.data : JSON.stringify({\n        ...otherArgs,\n        options: mergedOptions\n      }),\n      credentials: options?.includeCredentials ? \"include\" : \"same-origin\"\n    };\n    return { url, info, mergedOptions };\n  }\n  async request(args, options) {\n    const { url, info, mergedOptions } = this.makeRequestOptions(args, options);\n    const response = await fetch(url, info);\n    if (mergedOptions.retry_on_error !== false && response.status === 503 && !mergedOptions.wait_for_model) {\n      return this.request(args, {\n        ...mergedOptions,\n        wait_for_model: true\n      });\n    }\n    if (options?.blob) {\n      if (!response.ok) {\n        throw new Error(\"An error occurred while fetching the blob\");\n      }\n      return await response.blob();\n    }\n    const output = await response.json();\n    if (output.error) {\n      throw new Error(output.error);\n    }\n    return output;\n  }\n  /**\n   * Make request that uses server-sent events and returns response as a generator\n   */\n  async *streamingRequest(args, options) {\n    const { url, info, mergedOptions } = this.makeRequestOptions({ ...args, stream: true }, options);\n    const response = await fetch(url, info);\n    if (mergedOptions.retry_on_error !== false && response.status === 503 && !mergedOptions.wait_for_model) {\n      return this.streamingRequest(args, {\n        ...mergedOptions,\n        wait_for_model: true\n      });\n    }\n    if (!response.ok) {\n      if (response.headers.get(\"Content-Type\")?.startsWith(\"application/json\")) {\n        const output = await response.json();\n        if (output.error) {\n          throw new Error(output.error);\n        }\n      }\n      throw new Error(`Server response contains error: ${response.status}`);\n    }\n    if (response.headers.get(\"content-type\") !== \"text/event-stream\") {\n      throw new Error(\n        `Server does not support event stream content type, it returned ` + response.headers.get(\"content-type\")\n      );\n    }\n    if (!response.body) {\n      return;\n    }\n    const reader = response.body.getReader();\n    let events = [];\n    const onEvent = (event) => {\n      events.push(event);\n    };\n    const onChunk = getLines(\n      getMessages(\n        () => {\n        },\n        () => {\n        },\n        onEvent\n      )\n    );\n    try {\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done)\n          return;\n        onChunk(value);\n        for (const event of events) {\n          if (event.data.length > 0) {\n            yield JSON.parse(event.data);\n          }\n        }\n        events = [];\n      }\n    } finally {\n      reader.releaseLock();\n    }\n  }\n};\nexport {\n  HfInference,\n  TextGenerationStreamFinishReason\n};\n"],
  "mappings": ";;;;;AACA,SAAS,QAAQ,KAAK;AACpB,MAAI,MAAM,QAAQ,GAAG,GAAG;AACtB,WAAO;AAAA,EACT;AACA,SAAO,CAAC,GAAG;AACb;AAGA,SAAS,SAAS,QAAQ;AACxB,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI,yBAAyB;AAC7B,SAAO,SAAS,QAAQ,KAAK;AAC3B,QAAI,WAAW,QAAQ;AACrB,eAAS;AACT,iBAAW;AACX,oBAAc;AAAA,IAChB,OAAO;AACL,eAAS,OAAO,QAAQ,GAAG;AAAA,IAC7B;AACA,UAAM,YAAY,OAAO;AACzB,QAAI,YAAY;AAChB,WAAO,WAAW,WAAW;AAC3B,UAAI,wBAAwB;AAC1B,YAAI,OAAO,QAAQ,MAAM,IAAkB;AACzC,sBAAY,EAAE;AAAA,QAChB;AACA,iCAAyB;AAAA,MAC3B;AACA,UAAI,UAAU;AACd,aAAO,WAAW,aAAa,YAAY,IAAI,EAAE,UAAU;AACzD,gBAAQ,OAAO,QAAQ,GAAG;AAAA,UACxB,KAAK;AACH,gBAAI,gBAAgB,IAAI;AACtB,4BAAc,WAAW;AAAA,YAC3B;AACA;AAAA,UACF,KAAK;AACH,qCAAyB;AAAA,UAC3B,KAAK;AACH,sBAAU;AACV;AAAA,QACJ;AAAA,MACF;AACA,UAAI,YAAY,IAAI;AAClB;AAAA,MACF;AACA,aAAO,OAAO,SAAS,WAAW,OAAO,GAAG,WAAW;AACvD,kBAAY;AACZ,oBAAc;AAAA,IAChB;AACA,QAAI,cAAc,WAAW;AAC3B,eAAS;AAAA,IACX,WAAW,cAAc,GAAG;AAC1B,eAAS,OAAO,SAAS,SAAS;AAClC,kBAAY;AAAA,IACd;AAAA,EACF;AACF;AACA,SAAS,YAAY,MAAM,SAAS,WAAW;AAC7C,MAAI,UAAU,WAAW;AACzB,QAAM,UAAU,IAAI,YAAY;AAChC,SAAO,SAAS,OAAO,MAAM,aAAa;AACxC,QAAI,KAAK,WAAW,GAAG;AACrB,6CAAY;AACZ,gBAAU,WAAW;AAAA,IACvB,WAAW,cAAc,GAAG;AAC1B,YAAM,QAAQ,QAAQ,OAAO,KAAK,SAAS,GAAG,WAAW,CAAC;AAC1D,YAAM,cAAc,eAAe,KAAK,cAAc,CAAC,MAAM,KAAiB,IAAI;AAClF,YAAM,QAAQ,QAAQ,OAAO,KAAK,SAAS,WAAW,CAAC;AACvD,cAAQ,OAAO;AAAA,QACb,KAAK;AACH,kBAAQ,OAAO,QAAQ,OAAO,QAAQ,OAAO,OAAO,QAAQ;AAC5D;AAAA,QACF,KAAK;AACH,kBAAQ,QAAQ;AAChB;AAAA,QACF,KAAK;AACH,eAAK,QAAQ,KAAK,KAAK;AACvB;AAAA,QACF,KAAK;AACH,gBAAM,QAAQ,SAAS,OAAO,EAAE;AAChC,cAAI,CAAC,MAAM,KAAK,GAAG;AACjB,oBAAQ,QAAQ,QAAQ,KAAK;AAAA,UAC/B;AACA;AAAA,MACJ;AAAA,IACF;AAAA,EACF;AACF;AACA,SAAS,OAAO,GAAG,GAAG;AACpB,QAAM,MAAM,IAAI,WAAW,EAAE,SAAS,EAAE,MAAM;AAC9C,MAAI,IAAI,CAAC;AACT,MAAI,IAAI,GAAG,EAAE,MAAM;AACnB,SAAO;AACT;AACA,SAAS,aAAa;AACpB,SAAO;AAAA,IACL,MAAM;AAAA,IACN,OAAO;AAAA,IACP,IAAI;AAAA,IACJ,OAAO;AAAA,EACT;AACF;AAGA,IAAI,4BAA4B;AAChC,IAAI,oCAAoD,CAAC,sCAAsC;AAC7F,oCAAkC,QAAQ,IAAI;AAC9C,oCAAkC,oBAAoB,IAAI;AAC1D,oCAAkC,cAAc,IAAI;AACpD,SAAO;AACT,GAAG,oCAAoC,CAAC,CAAC;AACzC,IAAI,cAAc,MAAM;AAAA,EAGtB,YAAY,SAAS,IAAI,iBAAiB,CAAC,GAAG;AAF9C;AACA;AAEE,SAAK,SAAS;AACd,SAAK,iBAAiB;AAAA,EACxB;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,SAAS,MAAM,SAAS;AAC5B,UAAM,MAAM,MAAM,KAAK,QAAQ,MAAM,OAAO;AAC5C,UAAM,gBAAgB,MAAM,QAAQ,GAAG,KAAK,IAAI;AAAA,MAC9C,CAAC,MAAM,OAAO,EAAE,UAAU,YAAY,OAAO,EAAE,aAAa,YAAY,OAAO,EAAE,UAAU,YAAY,OAAO,EAAE,cAAc;AAAA,IAChI;AACA,QAAI,CAAC,eAAe;AAClB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,cAAc,MAAM,SAAS;AACjC,UAAM,MAAM,MAAM,KAAK,QAAQ,MAAM,OAAO;AAC5C,UAAM,gBAAgB,MAAM,QAAQ,GAAG,KAAK,IAAI,MAAM,CAAC,MAAM,OAAO,EAAE,iBAAiB,QAAQ;AAC/F,QAAI,CAAC,eAAe;AAClB,YAAM,IAAI,UAAU,8EAA8E;AAAA,IACpG;AACA,WAAO,2BAAM;AAAA,EACf;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,eAAe,MAAM,SAAS;AAClC,UAAM,MAAM,MAAM,KAAK,QAAQ,MAAM,OAAO;AAC5C,UAAM,gBAAgB,OAAO,IAAI,WAAW,YAAY,OAAO,IAAI,QAAQ,YAAY,OAAO,IAAI,UAAU,YAAY,OAAO,IAAI,UAAU;AAC7I,QAAI,CAAC,eAAe;AAClB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,oBAAoB,MAAM,SAAS;AACvC,UAAM,MAAM,MAAM,KAAK,QAAQ,MAAM,OAAO;AAC5C,UAAM,gBAAgB,OAAO,IAAI,eAAe,YAAY,OAAO,IAAI,WAAW,YAAY,MAAM,QAAQ,IAAI,KAAK,KAAK,IAAI,MAAM,MAAM,CAAC,MAAM,OAAO,MAAM,QAAQ,KAAK,MAAM,QAAQ,IAAI,WAAW,KAAK,IAAI,YAAY,MAAM,CAAC,UAAU,MAAM,QAAQ,KAAK,KAAK,MAAM,MAAM,CAAC,MAAM,OAAO,MAAM,QAAQ,CAAC;AAC/S,QAAI,CAAC,eAAe;AAClB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,mBAAmB,MAAM,SAAS;AAjL1C;AAkLI,UAAM,OAAO,WAAM,KAAK,QAAQ,MAAM,OAAO,MAAhC,mBAAqC;AAClD,UAAM,gBAAgB,MAAM,QAAQ,GAAG,KAAK,IAAI,MAAM,CAAC,MAAM,OAAO,EAAE,UAAU,YAAY,OAAO,EAAE,UAAU,QAAQ;AACvH,QAAI,CAAC,eAAe;AAClB,YAAM,IAAI,UAAU,sFAAsF;AAAA,IAC5G;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,eAAe,MAAM,SAAS;AAClC,UAAM,MAAM,MAAM,KAAK,QAAQ,MAAM,OAAO;AAC5C,UAAM,gBAAgB,MAAM,QAAQ,GAAG,KAAK,IAAI,MAAM,CAAC,MAAM,OAAO,EAAE,mBAAmB,QAAQ;AACjG,QAAI,CAAC,eAAe;AAClB,YAAM,IAAI,UAAU,gFAAgF;AAAA,IACtG;AACA,WAAO,2BAAM;AAAA,EACf;AAAA;AAAA;AAAA;AAAA,EAIA,OAAO,qBAAqB,MAAM,SAAS;AACzC,WAAO,KAAK,iBAAiB,MAAM,OAAO;AAAA,EAC5C;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,oBAAoB,MAAM,SAAS;AACvC,UAAM,MAAM,QAAQ,MAAM,KAAK,QAAQ,MAAM,OAAO,CAAC;AACrD,UAAM,gBAAgB,MAAM,QAAQ,GAAG,KAAK,IAAI;AAAA,MAC9C,CAAC,MAAM,OAAO,EAAE,QAAQ,YAAY,OAAO,EAAE,iBAAiB,YAAY,OAAO,EAAE,UAAU,YAAY,OAAO,EAAE,UAAU,YAAY,OAAO,EAAE,SAAS;AAAA,IAC5J;AACA,QAAI,CAAC,eAAe;AAClB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,YAAY,MAAM,SAAS;AAC/B,UAAM,MAAM,MAAM,KAAK,QAAQ,MAAM,OAAO;AAC5C,UAAM,gBAAgB,MAAM,QAAQ,GAAG,KAAK,IAAI,MAAM,CAAC,MAAM,OAAO,EAAE,qBAAqB,QAAQ;AACnG,QAAI,CAAC,eAAe;AAClB,YAAM,IAAI,UAAU,kFAAkF;AAAA,IACxG;AACA,WAAO,2BAAM;AAAA,EACf;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,uBAAuB,MAAM,SAAS;AAC1C,UAAM,MAAM;AAAA,MACV,MAAM,KAAK,QAAQ,MAAM,OAAO;AAAA,IAClC;AACA,UAAM,gBAAgB,MAAM,QAAQ,GAAG,KAAK,IAAI;AAAA,MAC9C,CAAC,MAAM,MAAM,QAAQ,EAAE,MAAM,KAAK,EAAE,OAAO,MAAM,CAAC,WAAW,OAAO,WAAW,QAAQ,KAAK,MAAM,QAAQ,EAAE,MAAM,KAAK,EAAE,OAAO,MAAM,CAAC,WAAW,OAAO,WAAW,QAAQ,KAAK,OAAO,EAAE,aAAa;AAAA,IACzM;AACA,QAAI,CAAC,eAAe;AAClB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,eAAe,MAAM,SAAS;AAClC,UAAM,MAAM,MAAM,KAAK,QAAQ,MAAM,OAAO;AAC5C,UAAM,gBAAgB,MAAM,QAAQ,IAAI,aAAa,mBAAmB,KAAK,IAAI,aAAa,oBAAoB,MAAM,CAAC,MAAM,OAAO,MAAM,QAAQ,KAAK,MAAM,QAAQ,IAAI,aAAa,gBAAgB,KAAK,IAAI,aAAa,iBAAiB,MAAM,CAAC,MAAM,OAAO,MAAM,QAAQ,KAAK,OAAO,IAAI,mBAAmB,YAAY,MAAM,QAAQ,IAAI,QAAQ,KAAK,IAAI,SAAS,MAAM,CAAC,MAAM,OAAO,MAAM,QAAQ;AAC9Y,QAAI,CAAC,eAAe;AAClB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,kBAAkB,MAAM,SAAS;AACrC,UAAM,MAAM,MAAM,KAAK,QAAQ,MAAM,OAAO;AAC5C,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,2BAA2B,MAAM,SAAS;AAC9C,UAAM,MAAM,MAAM,KAAK,QAAQ,MAAM;AAAA,MACnC,GAAG;AAAA,MACH,QAAQ;AAAA,IACV,CAAC;AACD,UAAM,gBAAgB,OAAO,IAAI,SAAS;AAC1C,QAAI,CAAC,eAAe;AAClB,YAAM,IAAI,UAAU,iEAAiE;AAAA,IACvF;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,oBAAoB,MAAM,SAAS;AACvC,UAAM,MAAM,MAAM,KAAK,QAAQ,MAAM;AAAA,MACnC,GAAG;AAAA,MACH,QAAQ;AAAA,IACV,CAAC;AACD,UAAM,gBAAgB,MAAM,QAAQ,GAAG,KAAK,IAAI,MAAM,CAAC,MAAM,OAAO,EAAE,UAAU,YAAY,OAAO,EAAE,UAAU,QAAQ;AACvH,QAAI,CAAC,eAAe;AAClB,YAAM,IAAI,UAAU,sFAAsF;AAAA,IAC5G;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,oBAAoB,MAAM,SAAS;AACvC,UAAM,MAAM,MAAM,KAAK,QAAQ,MAAM;AAAA,MACnC,GAAG;AAAA,MACH,QAAQ;AAAA,IACV,CAAC;AACD,UAAM,gBAAgB,MAAM,QAAQ,GAAG,KAAK,IAAI,MAAM,CAAC,MAAM,OAAO,EAAE,UAAU,YAAY,OAAO,EAAE,UAAU,QAAQ;AACvH,QAAI,CAAC,eAAe;AAClB,YAAM,IAAI,UAAU,sFAAsF;AAAA,IAC5G;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,gBAAgB,MAAM,SAAS;AACnC,UAAM,MAAM,MAAM,KAAK,QAAQ,MAAM;AAAA,MACnC,GAAG;AAAA,MACH,QAAQ;AAAA,IACV,CAAC;AACD,UAAM,gBAAgB,MAAM,QAAQ,GAAG,KAAK,IAAI;AAAA,MAC9C,CAAC,MAAM,OAAO,EAAE,UAAU,YAAY,OAAO,EAAE,UAAU,YAAY,OAAO,EAAE,IAAI,SAAS,YAAY,OAAO,EAAE,IAAI,SAAS,YAAY,OAAO,EAAE,IAAI,SAAS,YAAY,OAAO,EAAE,IAAI,SAAS;AAAA,IACnM;AACA,QAAI,CAAC,eAAe;AAClB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,kBAAkB,MAAM,SAAS;AACrC,UAAM,MAAM,MAAM,KAAK,QAAQ,MAAM;AAAA,MACnC,GAAG;AAAA,MACH,QAAQ;AAAA,IACV,CAAC;AACD,UAAM,gBAAgB,MAAM,QAAQ,GAAG,KAAK,IAAI,MAAM,CAAC,MAAM,OAAO,EAAE,UAAU,YAAY,OAAO,EAAE,SAAS,YAAY,OAAO,EAAE,UAAU,QAAQ;AACrJ,QAAI,CAAC,eAAe;AAClB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,YAAY,MAAM,SAAS;AAC/B,UAAM,MAAM,MAAM,KAAK,QAAQ,MAAM;AAAA,MACnC,GAAG;AAAA,MACH,MAAM;AAAA,IACR,CAAC;AACD,UAAM,gBAAgB,OAAO,eAAe;AAC5C,QAAI,CAAC,eAAe;AAClB,YAAM,IAAI,UAAU,4EAA4E;AAAA,IAClG;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,YAAY,MAAM,SAAS;AA7WnC;AA8WI,YAAQ,WAAM,KAAK,QAAQ,MAAM;AAAA,MAC/B,GAAG;AAAA,MACH,QAAQ;AAAA,IACV,CAAC,MAHO,mBAGF;AAAA,EACR;AAAA;AAAA;AAAA;AAAA,EAIA,mBAAmB,MAAM,SAAS;AAChC,UAAM,gBAAgB,EAAE,GAAG,KAAK,gBAAgB,GAAG,QAAQ;AAC3D,UAAM,EAAE,OAAO,GAAG,UAAU,IAAI;AAChC,UAAM,UAAU,CAAC;AACjB,QAAI,KAAK,QAAQ;AACf,cAAQ,eAAe,IAAI,UAAU,KAAK,MAAM;AAAA,IAClD;AACA,QAAI,EAAC,mCAAS,SAAQ;AACpB,cAAQ,cAAc,IAAI;AAAA,IAC5B;AACA,QAAI,mCAAS,QAAQ;AACnB,UAAI,cAAc,gBAAgB;AAChC,gBAAQ,kBAAkB,IAAI;AAAA,MAChC;AACA,UAAI,cAAc,cAAc,OAAO;AACrC,gBAAQ,aAAa,IAAI;AAAA,MAC3B;AACA,UAAI,cAAc,iBAAiB;AACjC,gBAAQ,cAAc,IAAI;AAAA,MAC5B;AAAA,IACF;AACA,UAAM,MAAM,GAAG,yBAAyB,GAAG,KAAK;AAChD,UAAM,OAAO;AAAA,MACX;AAAA,MACA,QAAQ;AAAA,MACR,OAAM,mCAAS,UAAS,KAAK,OAAO,KAAK,UAAU;AAAA,QACjD,GAAG;AAAA,QACH,SAAS;AAAA,MACX,CAAC;AAAA,MACD,cAAa,mCAAS,sBAAqB,YAAY;AAAA,IACzD;AACA,WAAO,EAAE,KAAK,MAAM,cAAc;AAAA,EACpC;AAAA,EACA,MAAM,QAAQ,MAAM,SAAS;AAC3B,UAAM,EAAE,KAAK,MAAM,cAAc,IAAI,KAAK,mBAAmB,MAAM,OAAO;AAC1E,UAAM,WAAW,MAAM,MAAM,KAAK,IAAI;AACtC,QAAI,cAAc,mBAAmB,SAAS,SAAS,WAAW,OAAO,CAAC,cAAc,gBAAgB;AACtG,aAAO,KAAK,QAAQ,MAAM;AAAA,QACxB,GAAG;AAAA,QACH,gBAAgB;AAAA,MAClB,CAAC;AAAA,IACH;AACA,QAAI,mCAAS,MAAM;AACjB,UAAI,CAAC,SAAS,IAAI;AAChB,cAAM,IAAI,MAAM,2CAA2C;AAAA,MAC7D;AACA,aAAO,MAAM,SAAS,KAAK;AAAA,IAC7B;AACA,UAAM,SAAS,MAAM,SAAS,KAAK;AACnC,QAAI,OAAO,OAAO;AAChB,YAAM,IAAI,MAAM,OAAO,KAAK;AAAA,IAC9B;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAIA,OAAO,iBAAiB,MAAM,SAAS;AA/azC;AAgbI,UAAM,EAAE,KAAK,MAAM,cAAc,IAAI,KAAK,mBAAmB,EAAE,GAAG,MAAM,QAAQ,KAAK,GAAG,OAAO;AAC/F,UAAM,WAAW,MAAM,MAAM,KAAK,IAAI;AACtC,QAAI,cAAc,mBAAmB,SAAS,SAAS,WAAW,OAAO,CAAC,cAAc,gBAAgB;AACtG,aAAO,KAAK,iBAAiB,MAAM;AAAA,QACjC,GAAG;AAAA,QACH,gBAAgB;AAAA,MAClB,CAAC;AAAA,IACH;AACA,QAAI,CAAC,SAAS,IAAI;AAChB,WAAI,cAAS,QAAQ,IAAI,cAAc,MAAnC,mBAAsC,WAAW,qBAAqB;AACxE,cAAM,SAAS,MAAM,SAAS,KAAK;AACnC,YAAI,OAAO,OAAO;AAChB,gBAAM,IAAI,MAAM,OAAO,KAAK;AAAA,QAC9B;AAAA,MACF;AACA,YAAM,IAAI,MAAM,mCAAmC,SAAS,MAAM,EAAE;AAAA,IACtE;AACA,QAAI,SAAS,QAAQ,IAAI,cAAc,MAAM,qBAAqB;AAChE,YAAM,IAAI;AAAA,QACR,oEAAoE,SAAS,QAAQ,IAAI,cAAc;AAAA,MACzG;AAAA,IACF;AACA,QAAI,CAAC,SAAS,MAAM;AAClB;AAAA,IACF;AACA,UAAM,SAAS,SAAS,KAAK,UAAU;AACvC,QAAI,SAAS,CAAC;AACd,UAAM,UAAU,CAAC,UAAU;AACzB,aAAO,KAAK,KAAK;AAAA,IACnB;AACA,UAAM,UAAU;AAAA,MACd;AAAA,QACE,MAAM;AAAA,QACN;AAAA,QACA,MAAM;AAAA,QACN;AAAA,QACA;AAAA,MACF;AAAA,IACF;AACA,QAAI;AACF,aAAO,MAAM;AACX,cAAM,EAAE,MAAM,MAAM,IAAI,MAAM,OAAO,KAAK;AAC1C,YAAI;AACF;AACF,gBAAQ,KAAK;AACb,mBAAW,SAAS,QAAQ;AAC1B,cAAI,MAAM,KAAK,SAAS,GAAG;AACzB,kBAAM,KAAK,MAAM,MAAM,IAAI;AAAA,UAC7B;AAAA,QACF;AACA,iBAAS,CAAC;AAAA,MACZ;AAAA,IACF,UAAE;AACA,aAAO,YAAY;AAAA,IACrB;AAAA,EACF;AACF;",
  "names": []
}
